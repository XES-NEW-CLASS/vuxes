(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-2d0b289c"],{2514:function(e,s,t){"use strict";t.r(s);var a=function(){var e=this,s=e.$createElement;e._self._c;return e._m(0)},c=[function(){var e=this,s=e.$createElement,t=e._self._c||s;return t("section",[t("h1",[e._v("Git 规范")]),t("p",[e._v("使用 Feature Branching 工作流")]),t("ul",[t("li",[e._v("任何新的功能（feature）或 bug 修复全都新建一个 branch 来写； "),t("ul",[t("li",[e._v("功能分支命名例子 "),t("code",{pre:!0,attrs:{class:"code_inline"}},[e._v("feature/button")])]),t("li",[e._v("Bug修复分支命名例子"),t("code",{pre:!0,attrs:{class:"code_inline"}},[e._v("bugfix/button")])])])]),t("li",[e._v("branch 写完后，合并到主开发分支并删除。")])]),t("p",[e._v("项目主开发分支以 dev + 版本号方式命名，例如："),t("code",{pre:!0,attrs:{class:"code_inline"}},[e._v("dev/v0.0.1")])]),t("p",[e._v("项目发布分支以 release + 版本号方式命名，例如："),t("code",{pre:!0,attrs:{class:"code_inline"}},[e._v("release/v0.0.1")])]),t("p",[e._v("项目测试通过后，"),t("code",{pre:!0,attrs:{class:"code_inline"}},[e._v("release")]),e._v(" 合并到 "),t("code",{pre:!0,attrs:{class:"code_inline"}},[e._v("master")]),e._v(" 分支")]),t("h2",[e._v("工作流程")]),t("ul",[t("li",[e._v("开发组件库: 切出功能分支，例如 "),t("code",{pre:!0,attrs:{class:"code_inline"}},[e._v("feature/button")])]),t("li",[e._v("合并开发分支: 功能完成后合并到主开发分支")]),t("li",[e._v("组件库发布: 整个组件库功能完成时，从开发分支切出发布分支，并创建 tag 来标识这个版本，发布成功后合并到master，并删除所有 feature 分支及主开发分支"),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":"",class:"language-bash"}},[t("span",{pre:!0,attrs:{class:"hljs-comment"}},[e._v("# 当前分支 dev/v0.0.1")]),e._v("\ngit checkout -b release/v0.0.1\ngit tag -a v0.0.1 -m "),t("span",{pre:!0,attrs:{class:"hljs-string"}},[e._v("'Release version 0.0.1'")]),e._v("\n"),t("span",{pre:!0,attrs:{class:"hljs-comment"}},[e._v("# 当前分支 master")]),e._v("\ngit merge release/v0.0.1\n")])])])]),t("h2",[e._v("Git 分支命名参考")]),t("ul",[t("li",[t("code",{pre:!0,attrs:{class:"code_inline"}},[e._v("master")]),e._v("：主分支，与线上代码一致。")]),t("li",[t("code",{pre:!0,attrs:{class:"code_inline"}},[e._v("dev/版本号")]),e._v("：开发分支，相对稳定的版本，所有的- feature分支和bugfix分支都从该分支创建。其它分支为短期分支，其完成功能开发之后需要删除")]),t("li",[t("code",{pre:!0,attrs:{class:"code_inline"}},[e._v("feature/*")]),e._v("：特性（功能）分支，用于开发新的功能，不同的功能创建不同的功能分支，功能分支开发完成并自测通过之后，需要合并到 dev 分支，之后删除该分支。")]),t("li",[t("code",{pre:!0,attrs:{class:"code_inline"}},[e._v("bugfix/*")]),e._v("：bug修复分支，用于修复不紧急的bug，普通bug均需要创建bugfix分支开发，开发完成自测没问题后合并到 dev 分支后，删除该分支。")]),t("li",[t("code",{pre:!0,attrs:{class:"code_inline"}},[e._v("release/版本号")]),e._v("：发布分支，用于代码上线准备，该分支从dev分支创建，创建之后由测试同学发布到测试环境进行测试，测试过程中发现bug需要开发人员在该release分支上进行bug修复，所有bug修复完后，在上线之前，需要合并该release分支到master分支和dev分支。")]),t("li",[t("code",{pre:!0,attrs:{class:"code_inline"}},[e._v("hotfix/*")]),e._v("：紧急bug修复分支，该分支只有在紧急情况下使用，从master分支创建，用于紧急修复线上bug，修复完成后，需要合并该分支到master分支以便上线，同时需要再合并到dev分支。")])]),t("h2",[e._v("Git Commit Message格式")]),t("ul",[t("li",[t("code",{pre:!0,attrs:{class:"code_inline"}},[e._v("scope")]),e._v(": 一个可选的修改范围，用于标识此次提交主要涉及到代码中哪个模块。")]),t("li",[t("code",{pre:!0,attrs:{class:"code_inline"}},[e._v("type")]),e._v(" 提交类型： "),t("ul",[t("li",[t("code",{pre:!0,attrs:{class:"code_inline"}},[e._v("feat")]),e._v(": 新特性，新功能，表示在代码库中新增了一个功能（这和语义化版本中的 MINOR 相对应）")]),t("li",[t("code",{pre:!0,attrs:{class:"code_inline"}},[e._v("fix")]),e._v(": 表示在代码库中修复了一个 bug（这和语义化版本中的 PATCH 相对应）")]),t("li",[t("code",{pre:!0,attrs:{class:"code_inline"}},[e._v("docs")]),e._v(": 文档修改")]),t("li",[t("code",{pre:!0,attrs:{class:"code_inline"}},[e._v("style")]),e._v(": 格式化, 缺失分号等; 不包括生产代码变动")]),t("li",[t("code",{pre:!0,attrs:{class:"code_inline"}},[e._v("refactor")]),e._v(": 代码重构")]),t("li",[t("code",{pre:!0,attrs:{class:"code_inline"}},[e._v("perf")]),e._v(": 性能优化")]),t("li",[t("code",{pre:!0,attrs:{class:"code_inline"}},[e._v("test")]),e._v(": 添加缺失的测试, 重构测试, 不包括生产代码变动")]),t("li",[t("code",{pre:!0,attrs:{class:"code_inline"}},[e._v("build")]),e._v(": 构建任务相关的修改（比如gulp、webpack、npm）")]),t("li",[t("code",{pre:!0,attrs:{class:"code_inline"}},[e._v("ci")]),e._v(": 对CI配置文件和脚本的更改（比如：Travis，Circle，BrowserStack，SauceLabs）")]),t("li",[t("code",{pre:!0,attrs:{class:"code_inline"}},[e._v("chore")]),e._v(": 其他修改（不会修改src或测试文件的更改）")]),t("li",[t("code",{pre:!0,attrs:{class:"code_inline"}},[e._v("revert")]),e._v(": 回滚commit")])])]),t("li",[t("code",{pre:!0,attrs:{class:"code_inline"}},[e._v("subject")]),e._v(" 提交描述 "),t("ul",[t("li",[e._v("对应内容是commit 目的的简短描述，一般不超过50个字符")])])])]),t("p",[t("code",{pre:!0,attrs:{class:"code_inline"}},[e._v("description")]),e._v(": 简明扼要描述本次提交的内容，首字母无需大写，结尾不需要使用 .。")]),t("p",[t("code",{pre:!0,attrs:{class:"code_inline"}},[e._v("optional body")]),e._v(": 详细描述本次提交，比如此次变更的动机，如需换行，则使用 |。")]),t("p",[t("code",{pre:!0,attrs:{class:"code_inline"}},[e._v("optional footer")]),e._v(": 描述与之关联的 issue 或 break change。")]),t("div",{staticClass:"tip"},[t("p",[e._v("注意：提交类型 "),t("code",{pre:!0,attrs:{class:"code_inline"}},[e._v("feat")]),e._v(" 和 "),t("code",{pre:!0,attrs:{class:"code_inline"}},[e._v("fix")]),e._v(" 慎用，因为最终会生成 "),t("code",{pre:!0,attrs:{class:"code_inline"}},[e._v("CHANGELOG")]),e._v(" 版本日志，除非是明确开发了某个重要功能点或修复了某个bug。")])]),t("h2",[e._v("组件库发布 Github Tag")]),t("p",[e._v("当组件库完成时，我们可以创建一个tag来指向一个关键时期，比如版本号更新的时候可以建一个“v1.0”、“v2.0”之类的标签，这样在以后回顾的时候会比较方便。tag的使用很简单，主要操作有：")]),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":"",class:"language-bash"}},[t("span",{pre:!0,attrs:{class:"hljs-comment"}},[e._v("# 查看tag，列出所有tag，列出的tag是按字母排序的，和创建时间没关系。")]),e._v("\ngit tag\n"),t("span",{pre:!0,attrs:{class:"hljs-comment"}},[e._v("# v0.1.0")]),e._v("\n"),t("span",{pre:!0,attrs:{class:"hljs-comment"}},[e._v("# v0.1.1")]),e._v("\n\n"),t("span",{pre:!0,attrs:{class:"hljs-comment"}},[e._v("# 显示tag信息")]),e._v("\ngit show v0.1.0\n\n"),t("span",{pre:!0,attrs:{class:"hljs-comment"}},[e._v("# 创建tag")]),e._v("\ngit tag v0.1.0\n\n"),t("span",{pre:!0,attrs:{class:"hljs-comment"}},[e._v("# 带信息的tag：-m后面带的就是注释信息")]),e._v("\ngit tag -a v0.1.0 -m "),t("span",{pre:!0,attrs:{class:"hljs-string"}},[e._v("'Release version 0.1.0'")]),e._v("\n\n"),t("span",{pre:!0,attrs:{class:"hljs-comment"}},[e._v("# 我们在执行 git push 的时候，tag是不会上传到服务器的，比如现在的github，创建 tag 后 git push ，在github网页上是看不到tag 的，为了共享这些tag，你必须这样：")]),e._v("\ngit push origin v0.1.0\n"),t("span",{pre:!0,attrs:{class:"hljs-comment"}},[e._v("# or")]),e._v("\n"),t("span",{pre:!0,attrs:{class:"hljs-comment"}},[e._v("# 将所有tag 一次全部push到github上。")]),e._v("\ngit push origin --tags\n\n"),t("span",{pre:!0,attrs:{class:"hljs-comment"}},[e._v("# 删除tag")]),e._v("\n"),t("span",{pre:!0,attrs:{class:"hljs-comment"}},[e._v("# 删除本地tag")]),e._v("\ngit tag -d v0.1.0\n\n"),t("span",{pre:!0,attrs:{class:"hljs-comment"}},[e._v("# 删除github远端的指定tag")]),e._v("\ngit push origin :refs/tags/v0.1.0\n\n"),t("span",{pre:!0,attrs:{class:"hljs-comment"}},[e._v("# 创建一个基于指定tag的分支")]),e._v("\ngit checkout -b dev/v0.1.0 v0.1.0\n\n"),t("span",{pre:!0,attrs:{class:"hljs-comment"}},[e._v("# 切换到指定tag")]),e._v("\ngit checkout tag\n")])]),t("div",{staticClass:"tip"},[t("p",[e._v("切换到tag历史记录会处在分离头指针状态，这个时候修改是很危险的，在切换回主线时如果没有合并，之前的修改提交基本都会丢失，如果需要修改可以尝试 "),t("code",{pre:!0,attrs:{class:"code_inline"}},[e._v("git checkout -b branch tag")]),e._v(" 创建一个基于指定tag的分支，例如："),t("code",{pre:!0,attrs:{class:"code_inline"}},[e._v("git checkout -b tset v0.1.0")]),e._v(" 这个时候就会在分支上进行开发，之后可以切换到主线合并")])]),t("h2",[e._v("Git 操作技巧")]),t("p",[e._v("除了一些基本的 git 命令用法，这里列举几个工作中经常用到的命令")]),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":"",class:"language-bash"}},[t("span",{pre:!0,attrs:{class:"hljs-comment"}},[e._v("# merge 命令会造成 commit 历史分叉，如果不希望历史出现分叉，可以 rebase（在新位置重新提交）")]),e._v("\n"),t("span",{pre:!0,attrs:{class:"hljs-comment"}},[e._v("# 一般用 rebase 合并多个commit， rebase 是站在需要被 rebase 的 commit 上进行操作，这点和 merge 是不同的")]),e._v("\n"),t("span",{pre:!0,attrs:{class:"hljs-comment"}},[e._v("# merge使用")]),e._v("\ngit checkout master\ngit merge branch1\n\n"),t("span",{pre:!0,attrs:{class:"hljs-comment"}},[e._v("# rebase使用")]),e._v("\ngit rebase 目标基础点\n")])]),t("h3",[e._v("刚提交了一个代码，发现有几个地方写错了")]),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":"",class:"language-bash"}},[e._v("git commit --amend\n\n"),t("span",{pre:!0,attrs:{class:"hljs-comment"}},[e._v("# 如果集成了 commitizen，使用如下命令")]),e._v("\ngit cz --amend\n")])]),t("div",{staticClass:"tip"},[t("p",[e._v('"amend" 是「修正」的意思。在提交时，如果加上 --amend 参数，Git 不会在当前 commit 上增加 commit，而是会把当前 commit 里的内容和暂存区（stageing area）里的内容合并起来后创建一个新的 commit，用这个新的 commit 把当前 commit 替换掉。所以 commit --amend 做的事就是它的字面意思：对最新一条 commit 进行修正。')])]),t("h3",[e._v("如果写错的不是最新的提交，而是倒数第二个怎么办？")]),t("p",[t("code",{pre:!0,attrs:{class:"code_inline"}},[e._v("commit --amend")]),e._v(" 可以修复最新 commit 的错误，但如果是倒数第二个 commit，可以使用 "),t("code",{pre:!0,attrs:{class:"code_inline"}},[e._v("rebase -i")]),e._v("(交互式 rebase)，所谓「交互式 rebase」，就是在 "),t("code",{pre:!0,attrs:{class:"code_inline"}},[e._v("rebase")]),e._v(" 的操作执行之前，你可以指定要 "),t("code",{pre:!0,attrs:{class:"code_inline"}},[e._v("rebase")]),e._v(" 的 "),t("code",{pre:!0,attrs:{class:"code_inline"}},[e._v("commit")]),e._v(" 链中的每一个 "),t("code",{pre:!0,attrs:{class:"code_inline"}},[e._v("commit")]),e._v(" 是否需要进一步修改。")]),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":"",class:"language-bash"}},[e._v("git rebase -i HEAD^^\n"),t("span",{pre:!0,attrs:{class:"hljs-comment"}},[e._v("# or")]),e._v("\ngit rebase -i HEAD~2\n")])]),t("div",{staticClass:"tip"},[t("p",[e._v("说明：在 Git 中，有两个「偏移符号」： ^ 和 ~")]),t("p",[e._v("^ 的用法：在 commit 的后面加一个或多个 ^ 号，可以把 commit 往回偏移，偏移的数量是 ^ 的数量。")]),t("p",[e._v("~ 的用法：在 commit 的后面加上 ~ 号和一个数，可以把 commit 往回偏移，偏移的数量是 ~ 号后面的数。")])]),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":"",class:"language-bash"}},[t("span",{pre:!0,attrs:{class:"hljs-comment"}},[e._v("# 修改写错的 commit，用 commit --amend 来把修正应用到当前最新的 commit：")]),e._v("\ngit add .\ngit cz --amend\n\n"),t("span",{pre:!0,attrs:{class:"hljs-comment"}},[e._v("# 继续 rebase 过程，在修复完成之后，就可以用 rebase --continue 来继续 rebase 过程，把后面的 commit 直接应用上去")]),e._v("\ngit rebase --"),t("span",{pre:!0,attrs:{class:"hljs-built_in"}},[e._v("continue")]),e._v("\n")])]),t("h3",[e._v("直接丢弃刚写的提交")]),t("pre",{pre:!0},[t("code",{pre:!0,attrs:{"v-pre":"",class:"language-bash"}},[e._v("git reset --hard HEAD^\n")])])])}],r=t("2877"),n={},i=Object(r["a"])(n,a,c,!1,null,null,null);s["default"]=i.exports}}]);